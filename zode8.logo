;Tarj's Code
; Define structures and their fields
to tstruct :name :fields
  make :name :fields
end

; Define ExprC and its variants
to define-exprc
  tstruct "numC [n]
  tstruct "binopC [operation l r]
  tstruct "idC [s]
  tstruct "strC [str]
  tstruct "appC [first args]
  tstruct "squareC [a]
  tstruct "ifC [test then else]
  tstruct "lamC [args body]
end

; Define Value and its variants
to define-value
  tstruct "numV [n]
  tstruct "strV [str]
  tstruct "boolV [bool]
  tstruct "closV [args body env]
  tstruct "primOpV [op]
end

; Define environment and bindings
make "mt-env []
make "extend-env "cons

to add-bindings
  make "addbind (list '+ (list "primOpV '+))
  make "subbind (list '- (list "primOpV '-))
  make "multbind (list '* (list "primOpV '*))
  make "divbind (list '/ (list "primOpV '/))
  make "leqbind (list '<= (list "primOpV '<=))
  make "eqbind (list 'equal? (list "primOpV 'equal?))
  make "seqbind (list 'seq (list "primOpV 'seq))
  make "plusbind (list '++ (list "primOpV '++))
  make "readNumbind (list 'read-num (list "primOpV 'read-num))
  make "readStrbind (list 'read-str (list "primOpV 'read-str))
  make "printlnbind (list 'println (list "primOpV 'println))

  make "tbind (list 'true (list "boolV true))
  make "fbind (list 'false (list "boolV false))

  make "tl-env (list "tbind "fbind "addbind "subbind "multbind "divbind "leqbind "eqbind "seqbind "plusbind "readNumbind "readStrbind "printlnbind)
end

; Define basic operations
to eval :op :args :env
  if equal? (count :args) 1 [
    ifelse :op = 'seq [output :args] [output (list "boolV true)]
  ]
  if equal? (count :args) 0 [
    ifelse :op = 'seq [output :args] [output (list "boolV true)]
  ]
  output (list "numV 0) ; Default return value for unsupported operations
end

; Define interpreter function
to interp :a :env
  if listp :a [
    if equal? (first :a) "numC [output (list "numV (first (butfirst :a)))]
    if equal? (first :a) "strC [output (list "strV (first (butfirst :a)))]
    if equal? (first :a) "idC [output lookup (first (butfirst :a)) :env]
  ]
  output (list "numV 0) ; Default return value for unsupported expressions
end

; Define lookup function
to lookup :for :env
  if emptyp :env [show [Error: name not found] stop]
  if equal? (first :env) :for [output (second :env)]
  output lookup :for (butfirst :env)
end

; Define main program
to main
  define-exprc
  define-value
  add-bindings

  ; Example usage
  show eval '+ [5 7] "tl-env
  show interp (list "numC 15) "tl-env
  show interp (list "strC "hello") "tl-env
end

main
